# segmentation and ROI extraction code
import numpy as np
import os
import h5py
import subprocess
import pymorph
import mahotas
import tempfile

import scipy.stats as stats
import scipy.signal as sig
import scipy.ndimage as nd

__all__ = ['pickCells', 'extractTimeCoursesFromSeries', 'extractTimeCoursesFromStack', 'avgFromROIInSeries', 'avgFromROIInStack', 'allPixelsFromROIInSeries', 'refineMask', 'watershedSegment']

def pickCells(stack, seedPoints=None):
    """
    This is a wrapper function for MATLAB code that allows for semi-automated picking
    of cells via some MATLAB code from the Reid lab.  Depends on a simple matlab
    function which opens the hdf5 file and aligns the array, and writes it back out to
    another part of the hdf5 file

    Algorithm uses the average across time (axis=2) to form the image to pick cells with,
    generally is the average of the green channel

    Optional parameter seedPoints is a N x 2 np.array with coordinates of points to 'pre-click'
    Generated by core.morphProcessing.buildSeedPoints, for example.  Ideally sorted by brightest
    to dimmest object.

    Returns two 2d arrays- one is a binary array and one a labeled array

    :param stack: 3d nparray to use for picking.  
    :param seedPoints: optional, N x 2 numpy array
    :returns: (bwOut, mask): tuple of binary mask and labeled mask, both 2d numpy arrays
    """

    fovimage = np.mean(np.atleast_3d(stack),axis=2)

    temp_dir = tempfile.mkdtemp()
    
    f = h5py.File(os.path.join(temp_dir, 'temp.hdf5'))
    f.create_dataset('fovimage',data=fovimage)
    if seedPoints is not None:
        f.create_dataset('seedPoints',data=seedPoints)
        #    else:
        #        f.create_dataset('seedPoints',data=np.array([]))
    f.close()

    # call picking code (external matlab function, yuck)
    print 'Launching MATLAB to pick cells...\n'
    handle = subprocess.Popen('matlab -nodesktop -r \'imCellEditinteractiveExternal\'',stdin=open('/dev/null'), shell=True, executable="/bin/bash", cwd=temp_dir)
    handle.wait()

    # import the masks and delete temporary files
    f = h5py.File(os.path.join(temp_dir, 'temp.hdf5'),'r')
    bwOut = np.array(f.get('bwOut')[:])
    #    mask = np.array(f.get('mask')[:])
    f.close()

    os.system("rm -rf " + temp_dir)

    return bwOut, pymorph.label(bwOut)

def extractTimeCoursesFromSeries(imageSeries, mask):
    """Get timecourses of stack regions defined by a index 2-D array

    Really just a wrapper around extractTimeCoursesFromStack
    adds a dimension, extracts, and squeezes.

    Returns a N by time numpy array where N is the number of objects
    in labelImage.

    :param series: X by Y by time
    :param mask: 2-D labeled image of cell masks
    :returns: numobjects by time numpy array
    """
    return np.squeeze(extractTimeCoursesFromStack(np.expand_dims(imageSeries, axis=3), mask))
    
def extractTimeCoursesFromStack(imageStack, mask):
    """Get timecourses of stack regions defined by a index 2-D array

    Returns a N by time by trial numpy array where N is the number of objects
    in labelImage.

    :param stack: X by Y by time by trial
    :param labelImage: 2-D labeled image of cell masks
    :returns: traces: a time by numobjects by trial numpy array
    """

    Xsize, Ysize, nTimePoints, nTrials = imageStack.shape

    objectLabels = set(mask.ravel())
    nObjects = len(objectLabels)
    traces = np.zeros((nTimePoints, nObjects, nTrials))

    for obj in objectLabels:
        index = mask == obj
        traces[:, obj, :] = avgFromROIInStack(imageStack, index)

    return traces

def avgFromROIInSeries(imageSeries, binaryMask):
    """Computes an avgerage time series across all pixels in the mask.  

    :param imageSeries: X by Y by time
    :param binaryMask: binary mask image
    :returns: objectTimeCourse: numpy array, 1D, timeseries
    """
    nPixels = np.sum(binaryMask)
    objectTimeCourse = np.sum(imageSeries[binaryMask,:],axis=0)/nPixels # all the time points, all the trials, for every X and Y which == object
    return objectTimeCourse

def avgFromROIInStack(imageStack, binaryMask):
    """Computes an avgerage timeseries across all pixels in the mask, for all trials in the stack.  

    :param imageStack: X by Y by time by trial
    :param binaryMask: binary mask image
    :returns: objectTimeCourse: numpy array, 2D, timeseries by object
    """
    nPixels=np.sum(binaryMask)
    objectTimeCourse = np.sum(imageStack[binaryMask,:,:],axis=0)/nPixels # all the time points, all the trials, for every X and Y which == object
    return objectTimeCourse

def allPixelsFromROIInSeries(imageSeries, binaryMask):
    """Computes an pixel by pixel timeseries for all pixels in the mask, for all trials in the image series.
    Similar to avgFromROIInSeries, but doesn't average.
    
    :param imageSeries: X by Y by time
    :param binaryMask: binary mask image
    :returns: pixelValues: numpy array, 2D, pixel number by time
    """
    pixelValues = np.zeros((binaryMask.sum(), imageSeries.shape[2]))
    for i in range(imageSeries.shape[2]):
        iii = imageSeries[:,:,i]
        pixelValues[:,i] = iii[binaryMask.astype('bool')]
    return pixelValues

def refineMask(mask, imageSeries, numDilations=3, thresh=0.5, se=None):
    def corrMaskWithSourcePreConv(imageSeriesSmoothed, dilatedBinaryMask, sourceSmoothed):

        corrImage = np.zeros((imageSeries.shape[0], imageSeries.shape[1]))

        bounds = np.squeeze(pymorph.blob(dilatedMask, 'boundingbox', output='data'))
        for x in range(bounds[1], bounds[3]):
            for y in range(bounds[0], bounds[2]):
                if dilatedBinaryMask[x,y]>0:
                    corr = stats.pearsonr(sourceSmoothed[1:-1], imageSeriesSmoothed[x,y,:])[0]
                    corrImage[x,y] = corr
        return corrImage

    # calculate box for smoothing
    box = sig.boxcar(3)
    box = box / box.sum()

    imageSeriesSmoothed = nd.convolve1d(imageSeries, box, axis=2, mode='mirror')

    completeRefinedMask = np.zeros_like(mask)

    if se is None:
        se = np.array([[0,1,0],[1,1,1],[0,1,0]])
        #se = np.array([[1,1,1],[1,1,1],[1,1,1]])
    seedMask = mask.copy() > 0
    for rep in range(numDilations):
        seedMask = pymorph.dilate(seedMask, se)
    
    for maskIndex in range(1,mask.max()+1):
        origMask = mask == maskIndex

        dilatedOrigMask = origMask.copy() > 0
        for rep in range(numDilations):
            dilatedOrigMask = pymorph.dilate(dilatedOrigMask, se)

        forbiddenMask = np.logical_or(np.logical_and(seedMask, np.logical_not(dilatedOrigMask)), pymorph.dilate(completeRefinedMask))

        # make smoothed source
        source = avgFromROIInSeries(imageSeries, origMask)
        sourceSmoothed = np.convolve(source, box)

        dilatedMask = (mask==maskIndex).copy()
        for rep in range(numDilations+1):
            dilatedMask = pymorph.dilate(dilatedMask)

        corrMask = corrMaskWithSourcePreConv(imageSeriesSmoothed, dilatedOrigMask, sourceSmoothed)
        threshMask = corrMask >= thresh

        newMask = np.logical_and(np.logical_not(forbiddenMask), np.logical_or(threshMask, origMask))
        
        #completeRefinedMask = np.logical_xor(completeRefinedMask, newMask)
        completeRefinedMask += (newMask>0)*maskIndex
        #pdb.set_trace()
        completeRefinedMask[completeRefinedMask > maskIndex] = 0
        
    return completeRefinedMask

def watershedSegment(image, diskSize=20):

    def gradientMagnitudue(image):
        sobel_x = nd.sobel(image.astype('double'), 0)
        sobel_y = nd.sobel(image.astype('double'), 1)
        return np.sqrt((sobel_x * sobel_x) + (sobel_y * sobel_y))    

    def imimposemin(image, mask, connectivity):
        fm = image.copy()
        fm[mask] = -9223372036854775800
        fm[np.logical_not(mask)] = 9223372036854775800

        fp1 = image + 1
        
        g = np.minimum(fp1, fm)
        
        j = infrec(fm, g)
        return j

    def infrec(f, g, Bc=None):
        if Bc is None: Bc = pymorph.secross()
        n = f.size
        return fast_conditional_dilate(f, g, Bc, n);

    def fast_conditional_dilate(f, g, Bc=None, n=1):
        if Bc is None:
            Bc = pymorph.secross()
        f = pymorph.intersec(f,g)
        for i in xrange(n):
            prev = f
            f = pymorph.intersec(mahotas.dilate(f, Bc), g)
            if pymorph.isequal(f, prev):
                break
        return f

    gradmag = gradientMagnitudue(image)

    ## compute foreground markers

    # open image to create flat regions at cell centers
    se_disk = pymorph.sedisk(diskSize) 
    image_opened = mahotas.open(image, se_disk);

    # define foreground markers as regional maxes of cells
    # this step is slow!
    foreground_markers = mahotas.regmax(image_opened)

    ## compute background markers

    # Threshold the image, cast it to the right datatype, and then calculate the distance image
    image_black_white = image_opened > mahotas.otsu(image_opened)
    image_black_white = image_black_white.astype('uint16')

    # note the inversion here- a key difference from the matlab algorithm
    # matlab distance is to nearest non-zero pixel
    # python distance is to nearest 0 pixel
    image_distance = pymorph.to_uint16(nd.distance_transform_edt(np.logical_not(image_black_white)))
    eight_conn = pymorph.sebox()

    distance_markers = mahotas.label(mahotas.regmin(image_distance, eight_conn))[0]
    image_dist_wshed, image_dist_wshed_lines = mahotas.cwatershed(image_distance, distance_markers, eight_conn, return_lines=True)
    background_markers = image_dist_wshed_lines - image_black_white

    all_markers = np.logical_or(foreground_markers, background_markers)

    # impose a min on the gradient image.  assumes int64
    gradmag2 = imimposemin(gradmag.astype(int), all_markers, eight_conn)

    # call watershed
    segmented_cells, segmented_cell_lines = mahotas.cwatershed(gradmag2, mahotas.label(all_markers)[0], eight_conn, return_lines=True)

    # seperate watershed regions
    segmented_cells[gradientMagnitudue(segmented_cells) > 0] = 0
    return segmented_cells > 0, segmented_cells
